import time
from functools import wraps

def retry(retries=3, exceptions=(Exception,), delay=0.1, backoff=1.0): # Chamada de "assinatura de função"
    # Validação básica de parâmetro
    if not isinstance(retries, int) or retries < 1:
        raise ValueError("retries deve ser int e >= 1")
    if not isinstance(delay, (int,float,)) or delay < 0:
        raise ValueError("delay deve ser int ou float e >= 0")
    if not isinstance(backoff, (int,float)) or backoff < 1:
        raise ValueError("backoff deve ser int ou float e >= 1")
    
    if not isinstance(exceptions, tuple): # Se a função não tiver passado uma tupla nas exceçõe, transformar em uma.
        exceptions = (exceptions,)
    for exc in exceptions:
        if not (isinstance(exc, type)) and issubclass(exc, BaseException): 
        # Verifica se as exceções passadas são, primeiramente, uma classe e, caso seja, verifica se está dentro das subclasses predeterminadas no BaseException
            raise TypeError("Parâmetro exceptions deve conter classes derivadas de BaseException")
    
    def decorador(func):
        @wraps(func) # Responsável por preservar os dados da função decorada. Se não tivesse, os dados da função seriam os do decorador.
        def wrapper(*args,**kwargs):
            tentativa_atual = 1
            atraso_atual = float(delay)
            
            while True:
                try:
                    return func(*args,**kwargs)
                except exceptions as err:
                    if tentativa_atual >= retries:
                        raise err
                    nome_erro = type(err).__name__
                    msg = str(err)
                    print(f"Tentativa {tentativa_atual} falhou: ({nome_erro}: {msg}), tentanto outra vez em {atraso_atual:.3f}s")
                    if atraso_atual > 0:
                        time.sleep(atraso_atual)
                    tentativa_atual += 1
                    atraso_atual *= backoff
        return wrapper
    return decorador
    
    
# Driver Code

contador_falhas = 0 # Usado para simular falhas e depois sucesso.

@retry(retries=4, exceptions=(ValueError,), delay=0.1, backoff=2.0) 
# OBS: apesar de @retry ser chamado como decorador, é importante notar que a função retry tem como retorno a função decoradora.
# Então, apesar de "retry" ser chamado, ele retorna a função "decorador" que olha para a função a ser decorada.

# O decorador tentará 3 vezes, aguardando 0.1 segundos para tentar novamente.
# Caso tenha o erro informado, ele informa. 
# O "backoff" é a quantidade de tempo (multiplica) que ele irá incrementar a cada tentativa.
def pode_falhar():
    global contador_falhas
    
    # Falha duas vezes e só então retorna OK
    if contador_falhas < 3:
        contador_falhas += 1
        raise ValueError("Deu ruim!")
    return "Deu bom"

print(pode_falhar())